import TelegramBot from 'node-telegram-bot-api';
import { decrypt } from '../utils/encryption.js';
import { checkRateLimit } from '../utils/validation.js';
import ReceiptProcessor from './ReceiptProcessor.js';
import ChatProcessor from './ChatProcessor.js';
import ExpenseService from './ExpenseService.js';
import ConversationStateManager from '../utils/conversationState.js';
import { parseMonthRange, isValidDateFormat, isValidAmount, formatDateRange } from '../utils/dateUtils.js';
import { generateCategoryPieChart } from '../utils/chartGenerator.js';
import https from 'https';

/**
 * Multi-bot manager that maintains separate bot instances for each user
 * Implements singleton pattern with Map<userId, botInstance>
 */
class BotManager {
  constructor(supabase) {
    this.supabase = supabase;
    this.bots = new Map(); // userId -> { bot, config, lastActivity }
    this.receiptProcessor = new ReceiptProcessor(supabase);
    this.chatProcessor = new ChatProcessor(supabase);
    this.expenseService = new ExpenseService(supabase);
    this.conversationManager = new ConversationStateManager();
    this.rateLimitMap = new Map(); // For rate limiting per user
    this.isShuttingDown = false;
    
    // Bind methods to maintain context
    this.handleMessage = this.handleMessage.bind(this);
    this.handlePhoto = this.handlePhoto.bind(this);
    this.handleError = this.handleError.bind(this);
  }

  /**
   * Initialize bot manager by loading all user configurations
   */
  async initialize() {
    console.log('ü§ñ Initializing Bot Manager...');
    console.log('üîÑ Clearing any cached bot instances to prevent stale user ID issues...');
    
    // Force clear any existing bots to prevent user ID cache issues
    this.bots.clear();
    
    try {
      // Test Supabase connection first
      console.log('üîç Testing Supabase connection...');
      console.log(`üì° Supabase URL: ${process.env.SUPABASE_URL}`);
      
      // Try a simple query to test connection
      const { data: testData, error: testError } = await this.supabase
        .from('user_configs')
        .select('count')
        .limit(1);

      if (testError) {
        console.error(`‚ùå Supabase connection failed: ${testError.message}`);
        console.error('üîß This usually means:');
        console.error('   1. Database schema not set up');
        console.error('   2. Wrong Supabase URL/keys');
        console.error('   3. RLS policies blocking access');
        console.log('üìù Running in fallback mode without database');
        console.log(`‚úÖ Bot Manager initialized in fallback mode`);
        return;
      }

      console.log('‚úÖ Supabase connection successful');

      // In development/test mode, skip bot initialization
      if (process.env.NODE_ENV === 'development' || !process.env.SUPABASE_URL?.includes('supabase.co')) {
        console.log('üìù Running in development mode - skipping bot initialization');
        console.log(`‚úÖ Bot Manager initialized in development mode`);
        return;
      }

      // Load all active user configurations
      const { data: configs, error } = await this.supabase
        .from('user_configs')
        .select('*')
        .not('telegram_bot_token', 'is', null);

      if (error) {
        throw new Error(`Failed to load user configs: ${error.message}`);
      }

      console.log(`üìä Found ${configs?.length || 0} user configurations`);

      // Initialize bot for each user
      for (const config of configs || []) {
        try {
          await this.createUserBot(config);
        } catch (error) {
          console.error(`Failed to create bot for user ${config.user_id}:`, error.message);
          await this.logError(config.user_id, error);
        }
      }

      console.log(`‚úÖ Bot Manager initialized with ${this.bots.size} active bots`);
    } catch (error) {
      console.error('‚ùå Failed to initialize Bot Manager:', error);
      throw error;
    }
  }

  /**
   * Create a new bot instance for a user
   */
  async createUserBot(config) {
    const userId = config.user_id;
    
    console.log(`üîç DEBUG: Creating bot for user ID: ${userId}`);
    console.log(`üîç DEBUG: Config details:`, {
      user_id: config.user_id,
      created_at: config.created_at,
      has_token: !!config.telegram_bot_token
    });
    
    try {
      // Decrypt bot token
      const botToken = decrypt(config.telegram_bot_token);
      if (!botToken) {
        throw new Error('Failed to decrypt bot token');
      }

      // Create bot instance with long polling
      const bot = new TelegramBot(botToken, { 
        polling: {
          interval: 300,
          autoStart: false
        }
      });

      // Set up message handlers
      bot.on('message', (msg) => this.handleMessage(msg, userId, config));
      bot.on('photo', (msg) => this.handlePhoto(msg, userId, config));
      bot.on('polling_error', (error) => this.handleError(userId, error));

      // Start polling
      await bot.startPolling();

      // Store bot instance
      this.bots.set(userId, {
        bot,
        config,
        lastActivity: new Date(),
        isActive: true
      });

      // Update session status
      await this.updateBotSession(userId, config.telegram_bot_username, true);

      console.log(`‚úÖ Bot created for user ${userId} (@${config.telegram_bot_username})`);
      
    } catch (error) {
      console.error(`‚ùå Failed to create bot for user ${userId}:`, error.message);
      await this.logError(userId, error);
      throw error;
    }
  }

  /**
   * Handle incoming text messages
   */
  async handleMessage(msg, userId, config) {
    if (this.isShuttingDown) return;

    try {
      // Rate limiting check
      if (!checkRateLimit(this.rateLimitMap, userId, 60000, 20)) {
        const bot = this.bots.get(userId)?.bot;
        if (bot) {
          await bot.sendMessage(msg.chat.id, '‚è∞ Too many requests. Please wait a moment before sending another message.');
        }
        return;
      }

      // Update last activity
      this.updateLastActivity(userId);

      // Skip photo messages (handled separately)
      if (msg.photo) return;

      // Process text message as command (replaces AI chat processing)
      const response = await this.handleTextCommand(msg.text, userId);
      
      const bot = this.bots.get(userId)?.bot;
      if (bot && response) {
        await bot.sendMessage(msg.chat.id, response, {
          parse_mode: 'Markdown',
          disable_web_page_preview: true
        });
      }

    } catch (error) {
      console.error(`Error handling message for user ${userId}:`, error);
      await this.logError(userId, error);
      
      // Send error message to user
      const bot = this.bots.get(userId)?.bot;
      if (bot) {
        await bot.sendMessage(msg.chat.id, '‚ùå Sorry, I encountered an error processing your message. Please try again.');
      }
    }
  }

  /**
   * Handle incoming photo messages (receipts)
   */
  async handlePhoto(msg, userId, config) {
    if (this.isShuttingDown) return;

    // DEBUG: Log user ID being used
    console.log(`üîç DEBUG: handlePhoto called with userId: ${userId}`);
    console.log(`üîç DEBUG: Chat ID: ${msg.chat.id}`);
    console.log(`üîç DEBUG: Config user_id: ${config?.user_id}`);

    try {
      // Rate limiting check
      if (!checkRateLimit(this.rateLimitMap, userId, 60000, 5)) {
        const bot = this.bots.get(userId)?.bot;
        if (bot) {
          await bot.sendMessage(msg.chat.id, '‚è∞ Too many photo uploads. Please wait a moment.');
        }
        return;
      }

      // Check for multiple photos in quick succession (prevent AI token waste)
      const now = Date.now();
      const lastPhotoTime = this.rateLimitMap.get(`photo_${userId}`) || 0;
      const timeSinceLastPhoto = now - lastPhotoTime;
      
      if (timeSinceLastPhoto < 10000) { // Less than 10 seconds since last photo
        const bot = this.bots.get(userId)?.bot;
        if (bot) {
          await bot.sendMessage(msg.chat.id, `‚ö†Ô∏è *Multiple Photos Detected*

Please wait ${Math.ceil((10000 - timeSinceLastPhoto) / 1000)} seconds before sending another receipt.

üí° *Tip:* Send one receipt photo at a time for best AI processing results.`, {
            parse_mode: 'Markdown'
          });
        }
        return;
      }

      // Update last photo time
      this.rateLimitMap.set(`photo_${userId}`, now);

      // Update last activity
      this.updateLastActivity(userId);

      const bot = this.bots.get(userId)?.bot;
      if (!bot) return;

      // Validate single photo message
      if (!msg.photo || msg.photo.length === 0) {
        await bot.sendMessage(msg.chat.id, '‚ùå No photo detected. Please send a clear receipt photo.');
        return;
      }

      // Check for media group (multiple photos sent at once)
      if (msg.media_group_id) {
        await bot.sendMessage(msg.chat.id, `‚ö†Ô∏è *Multiple Photos Not Allowed*

I can only process **one receipt photo at a time** to ensure accurate AI analysis and control processing costs.

üìã *Please:*
‚Ä¢ Send individual receipt photos one by one
‚Ä¢ Wait for processing to complete before sending the next
‚Ä¢ Ensure each photo shows a complete receipt

üí° *Tip:* Single photos get better AI recognition results!`, {
          parse_mode: 'Markdown'
        });
        return;
      }

      // Send step-by-step processing messages
      const statusMsg = await bot.sendMessage(msg.chat.id, 'üì∏ Receipt received! Starting analysis...');

      try {
        // Step 1: Download photo
        await bot.editMessageText('üì• Downloading photo...', {
          chat_id: msg.chat.id,
          message_id: statusMsg.message_id
        });

        const photos = msg.photo;
        const largestPhoto = photos[photos.length - 1];
        const file = await bot.getFile(largestPhoto.file_id);
        
        // Download file as buffer instead of saving to disk
        const fileUrl = `https://api.telegram.org/file/bot${bot.token}/${file.file_path}`;
        
        const photoBuffer = await new Promise((resolve, reject) => {
          https.get(fileUrl, (response) => {
            if (response.statusCode !== 200) {
              reject(new Error(`Failed to download photo: ${response.statusCode}`));
              return;
            }
            
            const chunks = [];
            response.on('data', (chunk) => chunks.push(chunk));
            response.on('end', () => resolve(Buffer.concat(chunks)));
            response.on('error', reject);
          }).on('error', reject);
        });

        // Step 2: Check Gemini API
        if (!config.gemini_api_key) {
          await bot.editMessageText('‚ö†Ô∏è Gemini AI not configured. Please complete setup to process receipts.', {
            chat_id: msg.chat.id,
            message_id: statusMsg.message_id
          });
          return;
        }

        // Step 3: Process with AI
        await bot.editMessageText('ü§ñ Analyzing receipt with AI...', {
          chat_id: msg.chat.id,
          message_id: statusMsg.message_id
        });

        const receiptData = await this.receiptProcessor.processReceipt(photoBuffer, userId, config);
        
        if (!receiptData) {
          throw new Error('AI failed to extract receipt data');
        }

        // Step 4: Check Google Sheets
        if (!config.google_access_token) {
          await bot.editMessageText('‚ö†Ô∏è Google Sheets not configured. Receipt processed but not saved to sheets.\n\n' + this.formatReceiptConfirmation(receiptData), {
            chat_id: msg.chat.id,
            message_id: statusMsg.message_id,
            parse_mode: 'Markdown'
          });
          return;
        }

        // Step 5: Save to sheets
        await bot.editMessageText('üìä Saving to Google Sheets...', {
          chat_id: msg.chat.id,
          message_id: statusMsg.message_id
        });

        // Complete success
        const confirmationText = this.formatReceiptConfirmation(receiptData);
        await bot.editMessageText(confirmationText, {
          chat_id: msg.chat.id,
          message_id: statusMsg.message_id,
          parse_mode: 'Markdown'
        });

      } catch (processingError) {
        // Update message with error
        await bot.editMessageText(`‚ùå Error: ${processingError.message}`, {
          chat_id: msg.chat.id,
          message_id: statusMsg.message_id
        });
        throw processingError;
      }

    } catch (error) {
      console.error(`Error handling photo for user ${userId}:`, error);
      await this.logError(userId, error);
      
      const bot = this.bots.get(userId)?.bot;
      if (bot) {
        await bot.sendMessage(msg.chat.id, '‚ùå Sorry, I couldn\'t process this receipt. Please try again with a clearer photo.');
      }
    }
  }

  /**
   * Handle text commands (replaces AI chat processing to save tokens)
   */
  async handleTextCommand(text, userId) {
    const trimmedText = text.trim();
    const parts = trimmedText.split(' ');
    const command = parts[0].toLowerCase();
    const params = parts.slice(1);

    try {
      // Check if user is in conversation
      const conversation = this.conversationManager.getConversation(userId);
      if (conversation) {
        return this.handleConversationInput(userId, trimmedText, conversation);
      }

      // Handle regular commands
      switch (command) {
        case '/start':
          return this.getStartMessage();
        
        case '/help':
          return this.getHelpMessage();
        
        case '/stats':
          const stats = await this.expenseService.getMonthlyStats(userId);
          return this.expenseService.formatMonthlyStats(stats);
        
        case '/today':
          const todayExpenses = await this.expenseService.getTodayExpenses(userId);
          return this.expenseService.formatExpenseSummary(todayExpenses, "Today's Expenses");
        
        case '/yesterday':
          const yesterdayExpenses = await this.expenseService.getYesterdayExpenses(userId);
          return this.expenseService.formatExpenseSummary(yesterdayExpenses, "Yesterday's Expenses");
        
        case '/week':
          const weekExpenses = await this.expenseService.getWeekExpenses(userId);
          return this.expenseService.formatExpenseSummary(weekExpenses, "This Week's Expenses");
        
        case '/month':
          const monthExpenses = await this.expenseService.getMonthExpenses(userId);
          return this.expenseService.formatExpenseSummary(monthExpenses, "This Month's Expenses");
        
        case '/summary':
          return this.handleSummaryCommand(userId, params);
        
        case '/create':
          return this.handleCreateCommand(userId);
        
        default:
          return this.getUnknownCommandMessage();
      }
    } catch (error) {
      console.error('Error handling command:', error);
      return '‚ùå Sorry, I encountered an error processing your request. Please try again.';
    }
  }

  /**
   * Handle /summary command with parameters
   */
  async handleSummaryCommand(userId, params) {
    if (params.length === 0) {
      return this.getSummaryUsageMessage();
    }

    const period = params.join(' ').toLowerCase();
    let expenses = [];
    let title = '';

    try {
      switch (period) {
        case 'day':
          expenses = await this.expenseService.getTodayExpenses(userId);
          title = "Today's Summary";
          break;
        
        case 'week':
          expenses = await this.expenseService.getWeekExpenses(userId);
          title = "This Week's Summary";
          break;
        
        case 'month':
          expenses = await this.expenseService.getMonthExpenses(userId);
          title = "This Month's Summary";
          break;
        
        default:
          // Try to parse as month range
          const range = parseMonthRange(period);
          if (range) {
            expenses = await this.expenseService.getCustomRangeExpenses(userId, range.startDate, range.endDate);
            title = `${formatDateRange(range)} Summary`;
          } else {
            return this.getSummaryUsageMessage();
          }
      }

      return await this.formatEnhancedSummary(expenses, title, userId);
    } catch (error) {
      console.error('Error in summary command:', error);
      return '‚ùå Sorry, I encountered an error generating your summary. Please try again.';
    }
  }

  /**
   * Handle /create command - start expense creation flow
   */
  async handleCreateCommand(userId) {
    this.conversationManager.startConversation(userId, 'create_expense');
    return `üí∞ *Create New Expense*

Please enter the receipt date in YYYY-MM-DD format.

üìÖ *Examples:*
‚Ä¢ 2025-01-15
‚Ä¢ 2025-08-24

Type the date or /cancel to stop:`;
  }

  /**
   * Handle conversation input for multi-step commands
   */
  async handleConversationInput(userId, input, conversation) {
    if (input.toLowerCase() === '/cancel') {
      this.conversationManager.endConversation(userId);
      return '‚ùå Operation cancelled.';
    }

    switch (conversation.type) {
      case 'create_expense':
        return this.handleCreateExpenseFlow(userId, input, conversation);
      default:
        this.conversationManager.endConversation(userId);
        return '‚ùå Unknown conversation type. Please try again.';
    }
  }

  /**
   * Handle create expense conversation flow
   */
  async handleCreateExpenseFlow(userId, input, conversation) {
    switch (conversation.step) {
      case 0: // Waiting for receipt date
        if (!isValidDateFormat(input)) {
          return `‚ùå Invalid date format. Please use YYYY-MM-DD format.

üìÖ *Examples:*
‚Ä¢ 2025-01-15
‚Ä¢ 2025-08-24

Please enter the receipt date or /cancel to stop:`;
        }
        
        this.conversationManager.updateStep(userId, 1, { receiptDate: input });
        return `‚úÖ Date set: ${input}

üè™ Please enter the store name:

*Examples:* Walmart, Target, Starbucks, etc.`;

      case 1: // Waiting for store name
        if (!input || input.trim().length < 1) {
          return `‚ùå Store name cannot be empty.

üè™ Please enter the store name:`;
        }

        this.conversationManager.updateStep(userId, 2, { storeName: input.trim() });
        const categories = this.expenseService.getAvailableCategories();
        let categoryMessage = `‚úÖ Store: ${input.trim()}

üìã Please select a category by typing the number:

`;
        categories.forEach((cat, index) => {
          categoryMessage += `${index + 1}. ${cat.label}\n`;
        });

        return categoryMessage;

      case 2: // Waiting for category selection
        const categoryIndex = parseInt(input) - 1;
        const availableCategories = this.expenseService.getAvailableCategories();
        
        if (isNaN(categoryIndex) || categoryIndex < 0 || categoryIndex >= availableCategories.length) {
          return `‚ùå Invalid selection. Please choose a number from 1 to ${availableCategories.length}:

${availableCategories.map((cat, index) => `${index + 1}. ${cat.label}`).join('\n')}`;
        }

        const selectedCategory = availableCategories[categoryIndex];
        this.conversationManager.updateStep(userId, 3, { category: selectedCategory.value });
        return `‚úÖ Category: ${selectedCategory.label}

üíµ Please enter the total amount (numbers only):

*Examples:* 25.99, 100, 15.50`;

      case 3: // Waiting for amount
        if (!isValidAmount(input)) {
          return `‚ùå Invalid amount. Please enter a positive number.

üíµ *Examples:* 25.99, 100, 15.50

Please enter the total amount:`;
        }

        const amount = parseFloat(input).toFixed(2);
        const expenseData = {
          receiptDate: conversation.data.receiptDate,
          storeName: conversation.data.storeName,
          category: conversation.data.category,
          totalAmount: amount
        };

        try {
          const createdExpense = await this.expenseService.createExpense(userId, expenseData);
          this.conversationManager.endConversation(userId);
          
          const categoryEmoji = this.expenseService.getCategoryEmoji(expenseData.category);
          return `‚úÖ *Expense Created Successfully!*

üìä *Summary:*
üìÖ Date: ${expenseData.receiptDate}
üè™ Store: ${expenseData.storeName}
üìã Category: ${categoryEmoji} ${this.expenseService.capitalizeFirst(expenseData.category)}
üí∞ Amount: $${amount}

The expense has been saved to your account.`;

        } catch (error) {
          console.error('Error creating expense:', error);
          this.conversationManager.endConversation(userId);
          return '‚ùå Sorry, there was an error saving your expense. Please try again with /create command.';
        }
    }
  }

  /**
   * Format enhanced summary with chart and top stores
   */
  async formatEnhancedSummary(expenses, title, userId) {
    if (!expenses || expenses.length === 0) {
      return `üìä *${title}*\nüí∞ Total: $0.00\nüìã No expenses found`;
    }

    const total = expenses.reduce((sum, expense) => sum + parseFloat(expense.total_amount), 0);
    const categories = this.expenseService.getCategoryBreakdown(expenses);
    const topStores = this.expenseService.getTopStores(expenses);

    let message = `üìä *${title}*\n`;
    message += `üí∞ Total: $${total.toFixed(2)}\n`;
    message += `üìã Transactions: ${expenses.length}\n\n`;

    // Category breakdown
    if (categories.length > 0) {
      message += `ü•ß *Category Breakdown:*\n`;
      categories.forEach(cat => {
        const emoji = this.expenseService.getCategoryEmoji(cat.category);
        message += `${emoji} ${this.expenseService.capitalizeFirst(cat.category)}: $${cat.amount} (${cat.percentage}%)\n`;
      });
      message += '\n';
    }

    // Top stores
    if (topStores.length > 0) {
      message += `üè™ *Top 5 Stores:*\n`;
      topStores.forEach((store, index) => {
        message += `${index + 1}. ${store.store}: $${store.total} (${store.count} visits)\n`;
      });
    }

    return message;
  }

  /**
   * Get summary usage message
   */
  getSummaryUsageMessage() {
    return `üìä *Summary Command Usage*

Usage: \`/summary <period>\`

*Available periods:*
‚Ä¢ \`day\` - Today's summary
‚Ä¢ \`week\` - This week's summary  
‚Ä¢ \`month\` - This month's summary
‚Ä¢ \`jan-aug\` - January to August
‚Ä¢ \`january-march\` - January to March
‚Ä¢ \`1-6\` - January to June

*Examples:*
‚Ä¢ \`/summary day\`
‚Ä¢ \`/summary week\`
‚Ä¢ \`/summary jan-aug\`
‚Ä¢ \`/summary january-march\``;
  }

  /**
   * Get start message with welcome and command list
   */
  getStartMessage() {
    return `üéâ *Welcome to AI Expense Tracker!*

I help you track expenses by processing receipt photos and answering questions about your spending.

üì∏ *Send me a photo* of your receipt for automatic expense tracking!

üìã *Available Commands:*

*üìä Analytics:*
‚Ä¢ /summary day - Today's detailed summary
‚Ä¢ /summary week - This week's summary  
‚Ä¢ /summary month - This month's summary
‚Ä¢ /summary jan-aug - Custom month range
‚Ä¢ /stats - Quick monthly overview
‚Ä¢ /today, /yesterday, /week, /month - Quick expense totals

*üí∞ Manual Entry:*
‚Ä¢ /create - Add expense manually (step-by-step)

*üìö Help:*
‚Ä¢ /help - Detailed command guide

üí° *Quick Start:*
1. Send receipt photos for auto-tracking
2. Use \`/summary week\` for weekly analysis
3. Use \`/create\` to add manual expenses

Type /help for detailed usage examples!`;
  }

  /**
   * Get help message
   */
  getHelpMessage() {
    return `ü§ñ *AI Expense Tracker - Complete Guide*

üì∏ *Photo Processing:*
‚Ä¢ Send **one receipt photo at a time** for automatic tracking
‚Ä¢ AI extracts store name, date, amount, and category
‚Ä¢ Wait for processing to complete before sending next photo
‚Ä¢ Multiple photos in one message will be rejected

üìä *Summary Commands (Enhanced Analytics):*
‚Ä¢ \`/summary day\` - Today's detailed breakdown
‚Ä¢ \`/summary week\` - This week's summary
‚Ä¢ \`/summary month\` - This month's summary
‚Ä¢ \`/summary jan-aug\` - January to August
‚Ä¢ \`/summary january-march\` - January to March  
‚Ä¢ \`/summary 1-6\` - January to June (numeric)

*Summary includes:* Total spend, category breakdown with percentages, top 5 stores

üìà *Quick Expense Queries:*
‚Ä¢ /stats - Quick monthly overview
‚Ä¢ /today - Today's total expenses
‚Ä¢ /yesterday - Yesterday's total expenses
‚Ä¢ /week - This week's total expenses
‚Ä¢ /month - This month's total expenses

üí∞ *Manual Expense Entry:*
‚Ä¢ \`/create\` - Add expense step-by-step
  ‚Üí Asks for date (YYYY-MM-DD)
  ‚Üí Store name
  ‚Üí Category selection (numbered menu)
  ‚Üí Amount

üí° *Pro Tips:*
‚Ä¢ Use month ranges: jan-dec, february-august, 3-9
‚Ä¢ Type /cancel during /create to stop
‚Ä¢ Send **single, clear receipt photos** for best AI results
‚Ä¢ Wait 10 seconds between photos to avoid rate limiting
‚Ä¢ Date format must be YYYY-MM-DD (e.g., 2025-01-15)

‚ùì Type any unknown command to see available options.`;
  }

  /**
   * Get message for unknown commands
   */
  getUnknownCommandMessage() {
    return `‚ùì *Unknown Command*

I only understand specific commands to save AI processing costs.

üìã *Available Commands:*

*üìä Detailed Analytics:*
‚Ä¢ /summary day, /summary week, /summary month
‚Ä¢ /summary jan-aug, /summary january-march

*üìà Quick Queries:*
‚Ä¢ /stats, /today, /yesterday, /week, /month

*üí∞ Manual Entry:*
‚Ä¢ /create - Step-by-step expense entry

*üìö Help:*
‚Ä¢ /start - Welcome & quick start
‚Ä¢ /help - Complete command guide

üí° *Try:*
‚Ä¢ \`/summary week\` - This week's detailed summary
‚Ä¢ \`/create\` - Add an expense manually
‚Ä¢ \`/help\` - See all features

üì∏ Or send me a *receipt photo* for automatic expense tracking!`;
  }

  /**
   * Handle bot errors and attempt recovery
   */
  async handleError(userId, error) {
    console.error(`Bot error for user ${userId}:`, error);
    
    // Log error for debugging
    await this.logError(userId, error);
    
    // Attempt bot restart
    try {
      await this.restartUserBot(userId);
      console.log(`‚úÖ Successfully restarted bot for user ${userId}`);
    } catch (restartError) {
      console.error(`‚ùå Failed to restart bot for user ${userId}:`, restartError);
      // Mark bot as inactive
      await this.updateBotSession(userId, null, false);
    }
  }

  /**
   * Restart a specific user's bot
   */
  async restartUserBot(userId) {
    // Stop existing bot
    const existingBot = this.bots.get(userId);
    if (existingBot?.bot) {
      try {
        await existingBot.bot.stopPolling();
      } catch (error) {
        console.warn(`Warning stopping bot for user ${userId}:`, error.message);
      }
    }

    // Remove from active bots
    this.bots.delete(userId);

    // Get fresh config
    const { data: config } = await this.supabase
      .from('user_configs')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (config && config.telegram_bot_token) {
      await this.createUserBot(config);
    }
  }

  /**
   * Add a new bot for a user (called when user completes setup)
   */
  async addUserBot(userId) {
    console.log(`üîÑ Adding/restarting bot for user ${userId}`);
    
    const { data: config } = await this.supabase
      .from('user_configs')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (config && config.telegram_bot_token) {
      // Force remove any existing bot first
      await this.removeUserBot(userId);
      
      // Wait a moment before creating new bot
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      await this.createUserBot(config);
      console.log(`‚úÖ Bot restarted successfully for user ${userId}`);
    } else {
      console.log(`‚ùå No valid config found for user ${userId}`);
    }
  }

  /**
   * Remove a user's bot (called when user disconnects)
   */
  async removeUserBot(userId) {
    const botData = this.bots.get(userId);
    if (botData?.bot) {
      try {
        await botData.bot.stopPolling();
      } catch (error) {
        console.warn(`Warning stopping bot for user ${userId}:`, error.message);
      }
    }
    
    this.bots.delete(userId);
    await this.updateBotSession(userId, null, false);
  }

  /**
   * Update bot session status in database
   */
  async updateBotSession(userId, botUsername, isActive) {
    try {
      const { error } = await this.supabase
        .from('bot_sessions')
        .upsert({
          user_id: userId,
          bot_username: botUsername,
          is_active: isActive,
          last_activity: new Date().toISOString()
        }, {
          onConflict: 'user_id'
        });

      if (error) {
        console.error('Failed to update bot session:', error);
      }
    } catch (error) {
      console.error('Error updating bot session:', error);
    }
  }

  /**
   * Update last activity timestamp
   */
  updateLastActivity(userId) {
    const botData = this.bots.get(userId);
    if (botData) {
      botData.lastActivity = new Date();
    }
  }

  /**
   * Log errors to database for debugging
   */
  async logError(userId, error) {
    try {
      await this.supabase
        .from('receipt_logs')
        .insert({
          user_id: userId,
          processing_status: 'error',
          error_message: error.message || error.toString(),
        });
    } catch (logError) {
      console.error('Failed to log error:', logError);
    }
  }

  /**
   * Format receipt confirmation message
   */
  formatReceiptConfirmation(receiptData) {
    // Escape special markdown characters
    const escapeMarkdown = (text) => {
      if (!text) return 'N/A';
      return text.toString().replace(/[_*[\]()~`>#+=|{}.!-]/g, '\\$&');
    };

    const itemsList = receiptData.items
      .map(item => `‚Ä¢ ${escapeMarkdown(item.name)}: $${(item.total || item.price || 0).toFixed(2)}`)
      .join('\n');

    return `‚úÖ *Receipt processed successfully\\!*

üè™ *Store:* ${escapeMarkdown(receiptData.store_name)}
üìÖ *Date:* ${escapeMarkdown(receiptData.date)}
üí∞ *Total:* $${receiptData.total.toFixed(2)}

*Items:*
${itemsList}

Your expense has been added to your Google Sheet\\! üìä`;
  }

  /**
   * Get bot statistics
   */
  getStats() {
    const activeBots = Array.from(this.bots.values()).filter(bot => bot.isActive).length;
    return {
      totalBots: this.bots.size,
      activeBots,
      uptime: process.uptime()
    };
  }

  /**
   * Graceful shutdown
   */
  async shutdown() {
    console.log('üõë Shutting down Bot Manager...');
    this.isShuttingDown = true;

    // Stop all bots
    const shutdownPromises = Array.from(this.bots.entries()).map(async ([userId, botData]) => {
      try {
        await botData.bot.stopPolling();
        await this.updateBotSession(userId, null, false);
      } catch (error) {
        console.warn(`Warning stopping bot for user ${userId}:`, error.message);
      }
    });

    await Promise.allSettled(shutdownPromises);
    this.bots.clear();
    
    console.log('‚úÖ Bot Manager shutdown complete');
  }
}

export default BotManager;